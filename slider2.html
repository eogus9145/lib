<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            height: 100%;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            flex-direction: column;
        }

        .test {
            width: 800px;
            height: 100px;
            border: 1px solid #000;
        }
    </style>
    <script>
        class Slider {
            constructor(cssSelector, option) {
                if (cssSelector.startsWith(".")) {
                    this.targetType = "class";
                } else if (cssSelector.startsWith("#")) {
                    this.targetType = "id";
                } else {
                    return;
                }
                this.cssSelector = cssSelector;
                this.option = option;
                this.divCnt = 1;
                this.position = 0;
                this.stopAnimate = false;
                this.destroyed = false;

                // option
                this.direction = (this.option && this.option.direction) ? this.option.direction : 'horizontal';
                this.speed = this.option && this.option.speed ? this.option.speed : 1;
                this.deg = (this.option && this.option.deg) ? this.option.deg : 0;
                this.gap = (this.option && this.option.gap) ? this.option.gap : 0;
                this.margin = (this.option.margin && this.option.margin) ? this.option.margin : 0;
                this.padding = (this.option && this.option.padding) ? this.option.padding : 0;
                this.reverse = this.option && this.option.reverse ? this.option.reverse : false;
                this.cross = (this.targetType == 'class' && this.option && this.option.cross) ? this.option.cross : false;
                this.fill = (this.option && this.option.fill) ? this.option.fill : true;

                this.animationFrameId = null; // 애니메이션 ID 저장
                this.eventListeners = []; // 이벤트 리스너 저장

                this.init();
            }

            async init() {
                document.addEventListener("DOMContentLoaded", async (e) => {
                    if (this.targetType == 'id') {
                        let target = document.querySelector(this.cssSelector);
                        this.setupSlider(target);
                    } else if (this.targetType == 'class') {
                        let targets = document.querySelectorAll(this.cssSelector);
                        targets.forEach(async (target, idx) => {
                            this.setupSlider(target, idx);
                        });
                    }
                });
            }

            async setupSlider(target, idx = 0) {
                this.targetWidth = target.offsetWidth;
                this.targetHeight = target.offsetHeight;
                if (idx > 0) target.style.marginLeft = this.margin + "px";
                let slide = target.querySelector(".slide");
                let items = slide.querySelectorAll(".slide-item");
                await this.resize(target, slide, idx, items);
                await this.sliding(slide, idx);
                await this.setEvent(slide);
            }

            async setEvent(slide) {
                const onMouseEnter = () => {
                    this.stopAnimate = true;
                    cancelAnimationFrame(this.animationFrameId);
                };

                const onMouseLeave = () => {
                    this.stopAnimate = false;
                    this.sliding(slide);
                };

                slide.addEventListener("mouseenter", onMouseEnter);
                slide.addEventListener("mouseleave", onMouseLeave);

                this.eventListeners.push({ element: slide, type: "mouseenter", listener: onMouseEnter });
                this.eventListeners.push({ element: slide, type: "mouseleave", listener: onMouseLeave });
            }

            async resize(target, slide, idx, items) {
                target.style.overflow = "hidden";
                target.style.position = "relative";
                target.style.backgroundColor = "#fff";

                slide.style.display = "flex";
                slide.style.position = "absolute";
                slide.style.gap = this.gap + "px";
                let imgDirection = "";

                if (this.direction == 'horizontal') {
                    slide.style.height = "100%";
                    slide.style.left = this.reverse ? "auto" : "0";
                    slide.style.right = this.reverse ? "0" : "auto";
                    imgDirection = "height";
                } else if (this.direction == 'vertical') {
                    slide.style.width = "100%";
                    slide.style.flexDirection = "column";
                    slide.style.top = this.reverse ? "auto" : "0";
                    slide.style.bottom = this.reverse ? "0" : "auto";
                    imgDirection = "width";
                }

                let totalWidth = 0;
                let totalHeight = 0;
                for (let item of items) {
                    item.style.padding = this.padding + "px";
                    let img = item.querySelector("img");
                    img.style[imgDirection] = "100%";
                    totalHeight += img.offsetHeight;
                    totalWidth += img.offsetWidth;
                }

                if (this.fill) {
                    if (this.direction == 'horizontal') {
                        this.divCnt += Math.ceil(target.offsetWidth / totalWidth);
                    } else if (this.direction == 'vertical') {
                        this.divCnt += Math.ceil(target.offsetHeight / totalHeight);
                    }

                    for (let j = 0; j < this.divCnt - 1; j++) {
                        for (let item of items) {
                            let clone = item.cloneNode(true);
                            slide.appendChild(clone);
                        }
                    }
                }

                if (this.deg != 0) {
                    target.style.transform = `rotate(${this.deg}deg)`;
                }
            }

            async sliding(slide) {
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                }

                const animate = () => {
                    if (this.stopAnimate || this.destroyed) {
                        return;
                    }

                    if (this.reverse) {
                        this.position += this.speed;
                        if (this.direction == 'horizontal') {
                            let limit = slide.scrollWidth / this.divCnt;
                            if (this.position >= limit) this.position = 0;
                            slide.style.transform = `translateX(${this.position}px)`;
                        } else if (this.direction == 'vertical') {
                            let limit = slide.scrollHeight / this.divCnt;
                            if (this.position >= limit) this.position = 0;
                            slide.style.transform = `translateY(${this.position}px)`;
                        }
                    } else {
                        this.position -= this.speed;
                        if (this.direction == 'horizontal') {
                            let limit = -(slide.scrollWidth / this.divCnt);
                            if (this.position < limit) this.position = 0;
                            slide.style.transform = `translateX(${this.position}px)`;
                        } else if (this.direction == 'vertical') {
                            let limit = -(slide.scrollHeight / this.divCnt);
                            if (this.position < limit) this.position = 0;
                            slide.style.transform = `translateY(${this.position}px)`;
                        }
                    }

                    this.animationFrameId = requestAnimationFrame(animate);
                };

                this.animationFrameId = requestAnimationFrame(animate);
            }

            destroy() {
                this.destroyed = true;
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                }

                this.eventListeners.forEach(({ element, type, listener }) => {
                    element.removeEventListener(type, listener);
                });
                this.eventListeners = [];
            }
        }
        
    </script>
</head>
<body>
    <div class="test">
        <div class="slide">
            <div class="slide-item">
                <img src="./sample1.png">
            </div>
            <div class="slide-item">
                <img src="./sample2.jpg">
            </div>
            <div class="slide-item">
                <img src="./sample3.gif">
            </div>
        </div>
    </div>

    <script>
        let slider = new Slider(
            ".test", 
            {
                direction: 'horizontal', 
                speed: 5, 
                deg: 0, 
                gap: 10, 
                margin : 0, 
                padding: 10,
            }
        );
        console.log(slider.cross);
    </script>
</body>
</html>
